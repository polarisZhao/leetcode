## åŠ¨æ€è§„åˆ’  

#### (1) å¸¸ç”¨æŠ€å·§æ€»ç»“

åŠ¨æ€è§„åˆ’åœ¨é¢è¯•ä¸­å æ®äº†ç»å¯¹çš„é‡è¦çš„åœ°ä½ï¼Œå€¼å¾—é‡ç‚¹çªç ´ã€‚ä¸‹é¢æ˜¯åŠ¨æ€è§„åˆ’è§£é¢˜çš„åŸºæœ¬æ­¥éª¤ï¼š

ï¼ˆ1ï¼‰ ç¡®å®šçŠ¶æ€: ç¡®å®š $dp[i]$  ä»£è¡¨ä»€ä¹ˆ ?  å¯ä»¥ä»è€ƒè™‘å­é—®é¢˜å’Œæœ€åä¸€æ­¥è¿›è¡Œè€ƒè™‘

ï¼ˆ2ï¼‰ ç¡®å®šè½¬ç§»æ–¹ç¨‹  $dp[i] = f(dp[i-1])$

ï¼ˆ3ï¼‰åˆå§‹æ¡ä»¶å’Œè¾¹ç•Œæƒ…å†µï¼šèµ·å§‹å€¼çš„èµ‹å€¼ & æœ€åä¸€æ­¥

ï¼ˆ4ï¼‰ è®¡ç®—é¡ºåº: æ¶ˆé™¤å†—ä½™ï¼ŒåŠ é€Ÿè®¡ç®—     $f[0],  f[1],  f[2],  ... $

å¸¸ç”¨æŠ€å·§ï¼š

- å¦‚ä½•ç¡®å®šæŸä¸ªé¢˜ç›®æ˜¯åŠ¨æ€è§„åˆ’ç±»çš„é¢˜ç›®:

  - count è®¡æ•°ï¼šæœ‰å¤šå°‘ç§æ–¹å¼èµ°åˆ°å³ä¸‹è§’ã€æœ‰å¤šå°‘ç§æ–¹å¼é€‰å‡º k ä¸ªæ•°ä½¿å¾—å’Œæ˜¯ sum

  - min/maxæ±‚æœ€å¤§æœ€å°å€¼ï¼šä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’è·¯å¾„çš„æœ€å¤§æ•°å­—å’Œã€æœ€é•¿ä¸Šå‡å­åºåˆ—é•¿åº¦

  - yes/no æ±‚å­˜åœ¨æ€§ï¼šå–çŸ³å­æ¸¸æˆï¼Œ å…ˆæ‰‹æ˜¯å¦å¿…èƒœã€èƒ½ä¸èƒ½é€‰å‡ºkä¸ªæ•°ä½¿å¾—å’Œæ˜¯Sum

- å¯¹äºå­—ç¬¦ä¸²çš„ç›¸å…³é—®é¢˜(å›æ–‡ã€å…¬å…±å­ä¸²ã€ä¸Šå‡å­ä¸²)ï¼Œ ä¸€ä¸ªå¾ˆå¸¸è§çš„æ“ä½œå°±æ˜¯ï¼Œç”¨å­—ç¬¦ä¸²æ„é€ çŸ©é˜µï¼Œç„¶åè¿›è¡ŒçŠ¶æ€è½¬ç§»ã€‚
- è§£é¢˜æ­¥éª¤ä¸­ï¼šç¡®å®šçŠ¶æ€å’Œç¡®å®šè½¬ç§»æ–¹ç¨‹æ˜¯æœ€é‡è¦çš„ã€‚
- æ²¡æœ‰æ€è·¯çš„æ—¶å€™å¯ä»¥ä»èµ·å§‹çŠ¶æ€è¿›è¡Œæ¨¡æ‹Ÿï¼Œæˆ–è€…å–å…¶ä¸­ä¸€ä¸ªç‰¹æ®Šçš„çŠ¶æ€è¿›è¡Œæ¨¡æ‹Ÿã€‚

  

#### (2) å…¸å‹ä¾‹é¢˜

##### ç±»å‹ä¸€ ç®€å•ä¸€ç»´ DP

###### [509] æ–æ³¢é‚£å¥‘æ•° https://leetcode-cn.com/problems/fibonacci-number/

~~~cpp
// ä½¿ç”¨ prev å’Œ cur æ¥æ¶ˆé™¤äº† DP æ•°ç»„çš„ä½¿ç”¨
int fib(int n) {
    if(n == 0) return 0;
    if(n == 1) return 1;
    int prev = 0, cur = 1;
    for(int i = 2; i <= n; i++){
        int s = (prev + cur) % 1000000007;
        prev = cur;
        cur = s;
    }
    return cur;
}
~~~

###### [70] çˆ¬æ¥¼æ¢¯ https://leetcode-cn.com/problems/climbing-stairs/

~~~cpp
int numWays(int n) {
    if(n <= 1) return 1;
    if(n == 2) return 2;
    int prev = 1, cur = 2;
    for(int i = 3; i <= n; i++){
        int s= (prev + cur) % 1000000007;
        prev = cur;
        cur = s;
    }
    return cur;
}
~~~

###### [198] https://leetcode.com/problems/house-robber/ 

~~~cpp
int rob(vector<int>& nums) {
    if(nums.size() == 0) return 0;
    if(nums.size() == 1) return nums[0];
    if(nums.size() == 2) return max(nums[0], nums[1]);

    vector<int > dp(nums.size(), 0);
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);

    int res = 2;
    for(int i = 2; i < nums.size(); i++){
        // è½¬ç§»æ–¹ç¨‹åªå’Œå‰ä¸¤ä¸ªçŠ¶æ€æœ‰å…³:
        // (1) é€‰æ‹©å½“å‰çš„æˆ¿å­: dp[i-2] + nums[i]
        // (2) ä¸é€‰å½“å‰æˆ¿å­: dp[i-1]
        dp[i] = max(dp[i-2] + nums[i], dp[i-1]);
    }
    return dp[nums.size()-1];
}
~~~

###### [264] https://leetcode-cn.com/problems/ugly-number-ii/    ğŸŒŸğŸŒŸğŸŒŸ

~~~cpp
// å…¶å®å°±æ˜¯ä¸æ–­çš„æ±‚æ•°ç»„ Aï¼Œ Bï¼Œ C çš„æœ€å°å€¼
// A: {1*2ï¼Œ2*2ï¼Œ3*2ï¼Œ4*2ï¼Œ5*2ï¼Œ6*2ï¼Œ8*2ï¼Œ10*2......}
// B: {1*3ï¼Œ2*3ï¼Œ3*3ï¼Œ4*3ï¼Œ5*3ï¼Œ6*3ï¼Œ8*3ï¼Œ10*3......}
// C: {1*5ï¼Œ2*5ï¼Œ3*5ï¼Œ4*5ï¼Œ5*5ï¼Œ6*5ï¼Œ8*5ï¼Œ10*5......}
int nthUglyNumber(int n) {
    vector<int> dp(n, 0);
    dp[0] = 1;
    int p2 = 0, p3 = 0, p5 = 0; // è¿™é‡Œæ˜¯ä¸‰ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘ä¸‰ä¸ªæ•°ç»„
    for(int i = 1; i < n; i++){
        // åªå’Œä¹‹å‰çš„ä¸‰ä¸ªå˜é‡æœ‰å…³ç³»
        dp[i] = min(min(dp[p2]*2, dp[p3]*3), dp[p5]*5);  
        if(dp[i]/dp[p2] == 2) p2++;
        if(dp[i]/dp[p3] == 3) p3++;
        if(dp[i]/dp[p5] == 5) p5++;
    }
    return dp[n-1];
}
~~~

###### [53] æœ€å¤§å­åºå’Œ https://leetcode-cn.com/problems/maximum-subarray/   ğŸŒŸğŸŒŸ

~~~cpp
int maxSubArray(vector<int>& nums) {
    if(nums.size() == 0) return 0;
    int res = nums[0];
    // ä»¥ dp ä¸ºç»“æŸçš„æœ€å¤§å­åºåˆ—çš„å’Œ
    vector<int> dp(nums.size(), 0); 
    dp[0] = nums[0];

    for(int i = 1; i < nums.size(); i++){
        dp[i] = dp[i-1] > 0 ? dp[i-1] + nums[i] : nums[i];
        res = max(res, dp[i]);
    }
    return res;
}

// è¿™é“é¢˜å’Œä¸Šé¢é‚£é“å‡ ä¹ç›¸åŒ: dp[i] çš„å®šä¹‰ç±»ä¼¼ï¼Œè½¬ç§»æ–¹ç¨‹ä¹Ÿç±»ä¼¼
~~~



##### ç±»å‹äºŒ ä¸€ç»´ DPï¼š ä¸ä¹‹å‰çš„æ‰€æœ‰çš„ dp çŠ¶æ€å‡æœ‰å…³ç³»

æ¥ä¸‹æ¥å‡ é“é¢˜ç›®è™½ç„¶å½¢å¼å„å¼‚ï¼Œä½†æ˜¯å½“å‰çš„çŠ¶æ€å’Œä¹‹å‰çš„æ‰€æœ‰çŠ¶æ€å‡æœ‰è”ç³»ã€‚

###### [lcof 14- I] å‰ªç»³å­ https://leetcode-cn.com/problems/jian-sheng-zi-lcof/

~~~cpp
int cuttingRope(int n) {
    if(n <= 3) return n-1;

    // dp[n] è¡¨ç¤ºé•¿åº¦ä¸º n çš„ç»³å­ï¼Œå‰ªæˆè‹¥å¹²æ®µä¹‹åï¼Œä¹˜ç§¯çš„æœ€å¤§å€¼
    vector<int> dp(n+1, 1);
    // å¦‚æœæŸä¸ªé•¿åº¦çš„ç»³å­ï¼Œå‰ªäº†ä¸€ä¸‹ä¹‹åï¼Œå…¶ä¸­ä¸€æ®µçš„é•¿åº¦åœ¨ [0,3] çš„åŒºé—´å†…ï¼Œå°±ä¸è¦å†å‰ªè¿™ä¸€æ®µäº†
    // å› ä¸ºå‰ªäº†ä¹‹åï¼Œä¹˜ç§¯ä¼šå˜å°
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 3;

    for(int i = 4;  i <= n; i++){   // é€æ¸å¢åŠ  dp æ•°ç»„çš„é•¿åº¦ 
        for(int j = 1; j <= i / 2; j++){     // ç¬¬ä¸€åˆ€å‰ªåœ¨ä»€ä¹ˆåœ°æ–¹?
            //  å‰©ä¸‹çš„ä¸¤æ®µä¸º j å’Œ i-jï¼Œ æ±‚è¿™ä¸¤æ®µçš„æœ€å¤§å€¼å³å¯
            dp[i] = max(dp[i], dp[j] * dp[i-j]);
        }
    }
    return dp[n];
}
~~~

###### [300]. æœ€é•¿ä¸Šå‡å­åºåˆ—](https://leetcode-cn.com/problems/longest-increasing-subsequence/)    ğŸŒŸğŸŒŸğŸŒŸ

~~~cpp
// æ ¸å¿ƒæ€æƒ³ï¼š
// å½“ nums[j] > nums[i] æ—¶ï¼š nums[j] å¯ä»¥æ¥åœ¨ nums[i] ä¹‹åï¼Œæ­¤æƒ…å†µä¸‹æœ€é•¿ä¸Šå‡å­åºåˆ—é•¿åº¦ä¸º dp[i] + 1 ï¼›
// å¦åˆ™ æ— æ³•æ¥åœ¨ nums[i]ä¹‹åï¼Œæ­¤æƒ…å†µä¸Šå‡å­åºåˆ—ä¸æˆç«‹ï¼Œè·³è¿‡ã€‚
int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    if(n == 0) return 0;

    vector<int> dp(n, 1);

    dp[0] = 1;
    for(int i = 0; i < n-1; i++){
        for(int j = i+1; j < n; j++){
            if(nums[j] > nums[i])
                dp[j] = max(dp[j], dp[i]+1);
        }
    }
    return *max_element(dp.begin(), dp.end());
}
~~~

###### [354] ä¿„ç½—æ–¯å¥—å¨ƒä¿¡å°é—®é¢˜ (https://leetcode-cn.com/problems/russian-doll-envelopes/)

~~~cpp
// å…ˆå°†ä¿¡å°æŒ‰ç…§ç¬¬ä¸€ä¸ªå…ƒç´ å‡åºï¼Œç¬¬äºŒä¸ªå…ƒç´ é™åºè¿›è¡Œæ’åˆ—ï¼Œ ç„¶åæ±‚æ‰€æœ‰ç¬¬äºŒä¸ªå…ƒç´ çš„æœ€é•¿é€’å¢å­åºåˆ—
int maxEnvelopes(vector<vector<int>>& envelopes) {
    sort(envelopes.begin(), envelopes.end(), [](vector<int> a, vector<int> b){
        return (a[0] < b[0]) || (a[0] == b[0] && a[1] > b[1]);
    });
    
    vector<int> nums;
    for(auto envelope: envelopes) nums.push_back(envelope[1]);
    return lengthOfLIS(nums);
}
~~~

æ¥ä¸‹æ¥è¿™ä¸¤é“é¢˜ç›®è™½ç„¶æ²¡æœ‰ç›´æ¥çš„ dp å½¢å¼ï¼Œä½†æ˜¯è•´å«çš„  dp æ€æƒ³ï¼Œè€Œä¸”æ˜¯å¯ä»¥å†™æˆ dp çš„ã€‚

###### [152] ä¹˜ç§¯æœ€å¤§å­æ•°ç»„ https://leetcode-cn.com/problems/maximum-product-subarray/

~~~cpp
// è¿™ä¸ªé¢˜ç›®æ˜¯ dp çš„æ€æƒ³åœ¨è§£å†³ï¼Œ ä½†æ˜¯ä¸æ˜¯ç”¨çš„ dp
// ç»´æŒä¸€ä¸ªæœ€å¤§å€¼å’Œä¸€ä¸ªæœ€å°å€¼çš„æ•°ç»„
int maxProduct(vector<int>& nums) {
    int res = INT_MIN;
    int min_val = 1, max_val = 1;
    for(auto n:nums){
        if(n < 0) swap(max_val, min_val);  // å¦‚æœå½“å‰å€¼å°äºé›¶ï¼Œåˆ™å¯¹æœ€å¤§å€¼å’Œæœ€å°å€¼è¿›è¡Œäº’æ¢
        min_val = min(min_val * n, n);
        max_val = max(max_val * n, n);

        res = max(res, max_val);
    }
    return res;
}
~~~

###### [376] æ‘†åŠ¨åºåˆ— https://leetcode-cn.com/problems/wiggle-subsequence/      ğŸŒŸğŸŒŸ

~~~c
// æ€è·¯å‚è€ƒ: https://leetcode-cn.com/problems/wiggle-subsequence/solution/tan-xin-si-lu-qing-xi-er-zheng-que-de-ti-jie-by-lg/
int wiggleMaxLength(vector<int>& nums) {
    if(nums.size() == 0) return 0;
    int up = 1, down = 1;

    for(int i = 1;  i < nums.size(); i++){
        if(nums[i] > nums[i-1]) up = down + 1;
        else if(nums[i] < nums[i-1]) down = up + 1;
    }
    return max(up, down);
}
~~~

##### ç±»å‹ä¸‰ï¼š äºŒç»´ DP

###### [62]  ä¸åŒè·¯å¾„ https://leetcode-cn.com/problems/unique-paths/  

~~~cpp
int uniquePaths(int m, int n) {
    vector<vector<int> > dp(m, vector<int>(n, 1));

    for(int i = 1; i < m; i++){
        for(int j = 1; j < n; j++){
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
}
~~~

###### [63] ä¸åŒè·¯å¾„ II https://leetcode-cn.com/problems/unique-paths-ii/      ğŸŒŸğŸŒŸ

~~~cpp
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    if(obstacleGrid.size() == 0 || obstacleGrid[0].size() == 0) return 0;
    int m = obstacleGrid.size(), n = obstacleGrid[0].size();
    vector<vector<int> > dp(m, vector<int>(n, 1));

    dp[0][0] = obstacleGrid[0][0] == 1 ? 0 : 1;
    for(int i = 1; i < m; i++)  dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i-1][0];
    for(int j = 1; j < n; j++)  dp[0][j] = obstacleGrid[0][j] == 1 ? 0 : dp[0][j-1];

    for(int i = 1; i < m; i++){
        for(int j = 1;  j < n; j++){
            dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i-1][j] + dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
}
~~~

###### [64] æœ€å°è·¯å¾„å’Œ https://leetcode-cn.com/problems/minimum-path-sum/

~~~cpp
int minPathSum(vector<vector<int>>& grid) {
    if(grid.size() == 0 || grid[0].size() == 0) return 0;
    int m = grid.size();
    int n = grid[0].size();

    vector<vector<int> > dp(m, vector<int>(n, 0));
    
    dp[0][0] = grid[0][0];
    for(int i = 1; i < n; i++) dp[0][i] = dp[0][i-1] + grid[0][i];
    for(int i = 1; i < m; i++) dp[i][0] = dp[i-1][0] + grid[i][0];

    for(int i = 1; i < m; i++){
        for(int j = 1; j < n; j++){
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
        }
    }
    return dp[m-1][n-1];
}
~~~

###### [lcof 47] https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/

~~~cpp
int maxValue(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    vector<vector<int> > dp(m, vector<int>(n));   // è¿™ä¸ªè¯­æ³•ä½¿ç”¨é”™äº†  vector

    dp[0][0] = grid[0][0];
    for(int i = 1; i < m; i++) dp[i][0] = dp[i-1][0] + grid[i][0];
    for(int j = 1; j < n; j++) dp[0][j] = dp[0][j-1] + grid[0][j];

    for(int i = 1; i < m; i++){
        for(int j = 1;  j < n; j++){
            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];
        }
    }
    return dp[m-1][n-1];
}
~~~

###### [120] ä¸‰è§’å½¢æœ€å°è·¯å¾„å’Œ https://leetcode-cn.com/problems/triangle/

~~~cpp
// ç›´æ¥åœ¨åŸæ•°ç»„ä¸Šæ›´æ”¹
int minimumTotal(vector<vector<int>>& triangle) {
    if(triangle.size() == 0 || triangle[0].size() == 0) return 0;
    int n = triangle.size();

    for(int i = 1; i < n; i++){
        for(int j = 0; j <= i; j++){
            if(j == 0) triangle[i][0] = triangle[i-1][0] + triangle[i][j];
            else if(j == i) triangle[i][i] = triangle[i-1][i-1] + triangle[i][j];
            else{
                triangle[i][j] = min(triangle[i-1][j-1], triangle[i-1][j]) + triangle[i][j];
            }
        }
    }

    int res = INT_MAX;
    for(int i = 0; i < n; i++)  res = min(res, triangle[n-1][i]);
    return res;
}
~~~



##### ç±»å‹å››ï¼š å­ä¸²å’Œå­åºåˆ—é—®é¢˜ï¼šä¸Šå‡ã€æ‘†åŠ¨ã€å›æ–‡ã€å…¬å…±

è¿™äº›é¢˜ç›®çš„å…±åŒè§£æ³•æ˜¯ä»¥å…¶ä¸­ä¸€ä¸ªå­—ç¬¦ä½œä¸ºè¡Œï¼Œ å¦ä¸€ä¸ªå­—ç¬¦ä½œä¸ºåˆ—ï¼Œ ç„¶ååˆ›å»ºäºŒç»´æ•°ç»„è¿›è¡Œéå†ã€‚

- æœ€é•¿å…¬å…±å­ä¸²/å­åºåˆ—

###### [718] æœ€é•¿é‡å¤å­æ•°ç»„ https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/  

~~~cpp
int findLength(vector<int>& A, vector<int>& B) {
    int res = 0;
    int m = A.size(), n = B.size();
    vector<vector<int> > dp(m, vector<int>(n, 0));

    // init
    for(int i = 0; i < m; i++) 
        if(A[i] == B[0]) dp[i][0] = 1;
    
    for(int i = 0;  i < n; i++)
        if(A[0] == B[i]) dp[0][i] = 1;

    // transform
    for(int i = 1; i < m; i++){
        for(int j = 1;  j < n; j++){
            if(A[i] == B[j]) 
                dp[i][j] = dp[i-1][j-1] + 1;
                res = max(res, dp[i][j]);
        }
    }
    return res;
}
~~~

###### [1143] æœ€é•¿å…¬å…±å­åºåˆ— https://leetcode-cn.com/problems/longest-common-subsequence/    ğŸŒŸğŸŒŸğŸŒŸ

~~~cpp
int longestCommonSubsequence(string text1, string text2) {
    int m = text1.size();
    int n = text2.size();

    vector<vector<int> > dp(m+1, vector<int>(n+1, 0));

    for(int i = 1; i <= m; i++){
        for(int j = 1; j<= n; j++){
            // å› ä¸ºçŸ©é˜µå¤§å°ä¸º (m+1)(n+1),  æ‰€ä»¥ i-1, j-1 å¯¹åº”çš„ dpçš„ i,j
            if(text1[i-1] == text2[j-1]){
                dp[i][j] = dp[i-1][j-1] + 1;
            }else{
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[m][n];
}
~~~

- æœ€é•¿å›æ–‡å­ä¸²/å­åºåˆ—

###### [5] æœ€é•¿å›æ–‡å­ä¸² https://leetcode-cn.com/problems/longest-palindromic-substring/    ğŸŒŸğŸŒŸ

~~~cpp
string palindrome(string str, int i, int j, int base){
    for(;i >= 0 && j < str.size() && str[i] == str[j]; i--, j++)   len += 2;
    return str.substr(i+1, base);

}

string longestPalindrome(string s) {
    string res = "";
    if(s.size() == 1) return s;

    string s1, s2;
    for(int i = 1; i < s.size(); i++){
        s1 = palindrome(s, i-1, i+1, 1);
        s2 = palindrome(s, i-1, i, 0);
        string max_str = s1.size() > s2.size() ? s1 : s2;
        res = res.size() > max_str.size() ? res : max_str;
    }
    return res;
}
~~~

###### [516] æœ€é•¿å›æ–‡å­åºåˆ— https://leetcode-cn.com/problems/longest-palindromic-subsequence/    ğŸŒŸğŸŒŸğŸŒŸ

~~~cpp
int longestPalindromeSubseq(string s) {

    int n = s.size();
    vector<vector<int> > dp(n, vector<int>(n));

    // dp[i][j]: j->i æœ€å¤§å›æ–‡å­ä¸²çš„é•¿åº¦
    for(int i = 0; i < n; i++) dp[i][i] = 1;

    for(int i = n-1; i >= 0; i--){
        for(int j = i+1; j < n; j++){
            if(s[i] == s[j]) 
                dp[i][j] = dp[i+1][j-1] + 2;
            else
                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
        }
    }
    return dp[0][n-1];
}
~~~

###### [583] ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œ https://leetcode-cn.com/problems/delete-operation-for-two-strings/

~~~cpp
int minDistance(string word1, string word2) {
    // å¯ä»¥è½¬æ¢ä¸ºæ±‚å…¬å…±å­ä¸²çš„é—®é¢˜
    if(word1.size() == 0 || word2.size() == 0) return 0;
    
    int m = word1.size();
    int n = word2.size();

    vector<vector<int> > dp(m+1, vector<int>(n+1, 0));
    for(int i = 1; i <= m; i++){
        for(int j = 1; j <= n; j++){
            if(word1[i-1] == word2[j-1]){
                dp[i][j] = dp[i-1][j-1] + 1;
            }else{
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return m + n - 2*dp[m][n];
}
~~~

###### [72] ç¼–è¾‘è·ç¦» https://leetcode-cn.com/problems/edit-distance/   ğŸŒŸğŸŒŸğŸŒŸ

~~~cpp
int minDistance(string word1, string word2) {
    if(word1.size() == 0) return word2.size();
    if(word2.size() == 0) return word1.size();

    int m = word1.size(), n = word2.size();
    vector<vector<int> > dp(m+1, vector<int>(n+1, 0));

    dp[0][0] = 0;
    for(int i = 1; i <= m; i++)   dp[i][0] = i;
    for(int j = 1; j <= n; j++) dp[0][j] = j;

    for(int i = 1;  i <= m; i++){
        for(int j = 1; j <= n; j++){
            if(word1[i-1] == word2[j-1])
                dp[i][j] = dp[i-1][j-1];
            else{
                dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;
            }
        }
    }
    return dp[m][n];
}
~~~



#####  ç±»å‹äº”: è‚¡ç¥¨äº¤æ˜“

è‚¡ç¥¨äº¤æ˜“é—®é¢˜ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹å‡ é“é¢˜ç›®ï¼š åŸå§‹çš„ä¹°å–è‚¡ç¥¨121ã€æ— é™æ¬¡æ“ä½œ122ã€åªèƒ½è¿›è¡Œä¸¤æ¬¡æ“ä½œ123ã€æœ€å¤š k æ¬¡188ã€å«å†·å†»æœŸ 309ã€å«æ‰‹ç»­è´¹ [714](https://leetcode-cn.com/problemset/50/)

###### [121]  ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/  ğŸŒŸğŸŒŸğŸŒŸ

~~~cpp
// å¯»æ‰¾ vector çš„æœ€å°å€¼ï¼Œç”¨åé¢çš„å€¼å‡å»ä¹‹å‰çš„æœ€å°å€¼
int maxProfit(vector<int>& prices) {
    int min_val = INT_MAX;
    int max_profit = 0;

    for(int i = 0; i < prices.size(); i++){
        min_val = min(min_val, prices[i]);
        max_profit = max(max_profit, prices[i] - min_val);
    }
    return max_profit <=0 ? 0 : max_profit;

}
~~~

###### [122] ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº

~~~cpp
// ç¬¬ i å¤©çš„æ”¶ç›Šä¸º profit = prices[i] - prices[i-1]
//ï¼ˆ1ï¼‰å½“ profit > 0 æ—¶ï¼Œå½“å¤©ä¹°å…¥å–å‡º
//ï¼ˆ2ï¼‰å½“ profit <= 0 æ—¶ï¼Œå½“å¤©ä¸è¿›è¡Œäº¤æ˜“
int maxProfit(vector<int>& prices) {
    int profit = 0;
    if(prices.size() <= 1) return 0;
    for(int i = 1; i < prices.size(); i++){
        if(prices[i] > prices[i-1])
            profit += (prices[i] - prices[i-1]);
    }
    return profit;
}
~~~



##### ç±»å‹ä¸ƒï¼š åˆ†å‰²æ•´æ•°

###### [343] https://leetcode-cn.com/problems/integer-break/  ğŸŒŸğŸŒŸ

~~~cpp
int cuttingRope(int n) {
    if(n == 2) return 1;
    if(n == 3) return 2;

    int mod = (int)1e9 + 7;
    long res = 1;
    // å½“å¤§äº 4 æ—¶å€™ï¼Œ ä¼˜å…ˆå‰ªæˆ 3, ä¹‹åä¹˜ä»¥å‰©ä¸‹çš„ä¸€æ®µ
    while(n > 4){
        res *= 3;
        res %= mod;
        n-=3;
    }
    res = (n * res) % mod;
    return res;  
}
~~~



##### å…¶ä»–

###### [lcof46] https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/  ğŸŒŸğŸŒŸ

~~~cpp
int translateNum(int num) {
    string str = to_string(num);
    int n = str.size();

    // dp[i] è¡¨ç¤ºå‰ i ä½ å¯ä»¥æœ‰å‡ ç§ç¿»è¯‘æ–¹æ³•
    vector<int> dp(n + 1, 1);

    for(int i = 1; i < n; i++){
        // å¦‚æœå‰ä¸€ä¸ªæ˜¯ 0ï¼Œ æˆ–è€… å‰ä¸€ä¸ªå’Œå½“å‰ > 25ï¼Œ é‚£ä¹ˆä¸èƒ½ç»„æˆä¸€ä¸ªæ–°å­—æ¯
        if (str[i-1] == '0' || str.substr(i-1, 2) > "25" ) {
            dp[i+1] = dp[i];
        } else {
            dp[i+1] = dp[i] + dp[i-1];
        }
    }

    return dp[str.size()];
}
~~~



##### ç±»å‹ä¸‰ èƒŒåŒ…é—®é¢˜

###### [322] é›¶é’±å…‘æ¢ https://leetcode-cn.com/problems/coin-change/  ğŸŒŸğŸŒŸğŸŒŸ

~~~cpp
int coinChange(vector<int>& coins, int amount) {
    //  dp[i]: é‡‘é¢ä¸ºiæ—¶å€™çš„æœ€å°ä½¿ç”¨å¼ æ•° -> åˆå§‹åŒ–ä¸º amount+1
    vector<int> dp(amount + 1, amount + 1);
    
    dp[0] = 0;
    for(int i = 1; i <= amount; i++){
        for(auto coin:coins){
            if(i >= coin)  dp[i] = min(dp[i], dp[i-coin] + 1);
        }
    }
    return dp[amount] == amount + 1 ? -1 : dp[amount];
}
~~~